#!/system/bin/sh
MODDIR=${0%/*}

TIMEOUT=300

CONFIG_DIR="/data/adb/bloatwareslayer"
LOG_DIR="$CONFIG_DIR/logs"
LOG_FILE="$LOG_DIR/bs_log_core_$(date +"%Y-%m-%d_%H-%M-%S").txt"

BRICKED_STATUS="$CONFIG_DIR/bricked"
EMPTY_DIR="$CONFIG_DIR/empty"

TARGET_LIST="$CONFIG_DIR/target.txt"
TARGET_LIST_BSA="$CONFIG_DIR/target_bsa.txt"
TARGET_LIST_UPD=true

SYSTEM_APP_PATHS="/system/app /system/product/app /system/product/priv-app /system/priv-app /system/system_ext/app /system/system_ext/priv-app /system/vendor/app /system/vendor/priv-app"

MODULE_PROP="${MODDIR}/module.prop"
MOD_NAME="$(sed -n 's/^name=\(.*\)/\1/p' "$MODULE_PROP")"
MOD_AUTHOR="$(sed -n 's/^author=\(.*\)/\1/p' "$MODULE_PROP")"
MOD_VER="$(sed -n 's/^version=\(.*\)/\1/p' "$MODULE_PROP") ($(sed -n 's/^versionCode=\(.*\)/\1/p' "$MODULE_PROP"))"

brick_rescue(){
    
    if [ -f "$BRICKED_STATUS" ]; then
        logowl "Detect flag bricked!" "FATAL"
        logowl "Skip service.sh process"
        DESCRIPTION="[‚ùåDisabled. Auto disabled from brick! Root: $ROOT_SOL] A Magisk module to remove bloatware in systemlessly way üéâ‚ú®"
        sed -i "/^description=/c\description=$DESCRIPTION" "$MODULE_PROP"
        logowl "Update module.prop"
        logowl "Skip mounting..."
        rm -rf "$BRICKED_STATUS"
        if [ $? -eq 0 ]; then
            logowl "Bricked status cleared"
        else
            logowl "Failed to clear bricked status" "FATAL"
        fi
        return 1    
    else
        logowl "Flag bricked does not detect"
        logowl "$MOD_NAME will keep going..."
    fi

}

preparation(){

    if [ -d "$EMPTY_DIR" ]; then
        logowl "Detect $EMPTY_DIR existed"
        rm -rf "$EMPTY_DIR"
    fi
    logowl "Create $EMPTY_DIR"
    mkdir -p "$EMPTY_DIR"
    chmod 755 "$EMPTY_DIR"

    if [ ! -f "$TARGET_LIST" ]; then
        logowl "Target list does not exist!" "FATAL"
        DESCRIPTION="[‚ùåDisabled. Target list does not exist! Root: $ROOT_SOL] A Magisk module to remove bloatware in systemlessly way‚ú®"
        update_module_description "$DESCRIPTION" "$MODULE_PROP"
        return 1
    fi

    if [ -f "$TARGET_LIST_BSA" ]; then
        logowl "target list ($MOD_NAME Arranged) file existed"
        if file_compare "$TARGET_LIST" "$TARGET_LIST_BSA"; then
            logowl "Files are identical, no changes detected"
            TARGET_LIST_UPD=false
        else
            logowl "Files are different, changes detected"
            TARGET_LIST_UPD=true
        fi
    fi

    if [ "$TARGET_LIST_UPD" == true ]; then
        TARGET_LIST_BSA_HEADER="# $MOD_NAME $MOD_VER
# Generate timestamp: $(date +"%Y-%m-%d %H:%M:%S")
# This file is generated by $MOD_NAME automatically, only to save the paths of the found APP(s)
# This file will update target.txt automatically if don't want to tidy target.txt up manually"
    touch "$TARGET_LIST_BSA"
    echo -e "$TARGET_LIST_BSA_HEADER\n" > "$TARGET_LIST_BSA"
    fi

}

bloatware_slayer(){

    TOTAL_APPS_COUNT=0
    BLOCKED_APPS_COUNT=0
    logowl "Start $MOD_NAME process"
    while IFS= read -r package; do
        if [[ "$package" =~ \\ ]]; then
            logowl "Replaced '\\' with '/' in path: $package" "WARN"
        fi
        package=$(echo "$package" | sed -e 's/^[[:space:]]*//' -e 's/\\/\//g')
        logowl "Current line: ${package:0:20}"
        if [ -z "$package" ]; then
            logowl "Detect empty line, skip processing" "WARN"
            continue
        elif [ "${package:0:1}" == "#" ]; then
            logowl 'Detect comment symbol "#", skip processing' "WARN"
            continue
        fi
        logowl "Process App: $package"
        TOTAL_APPS_COUNT=$((TOTAL_APPS_COUNT+1))
        for path in $SYSTEM_APP_PATHS; do
            if [[ "${package:0:1}" == "/" ]]; then
                app_path="$package"
                logowl "Detect custom dir: $app_path"
                if [[ ! "$app_path" =~ ^/system ]]; then
                    logowl "Unsupport custom path: $app_path" "WARN"
                    break
                fi
            else
                app_path="$path/$package"
            fi
            logowl "Checking dir: $app_path"
            if [ -d "$app_path" ]; then
                logowl "Execute mount -o bind $EMPTY_DIR $app_path"
                mount -o bind "$EMPTY_DIR" "$app_path"
                if [ $? -eq 0 ]; then
                    logowl "Succeeded"
                    if [ "$TARGET_LIST_UPD" == true ]; then
                        echo "$app_path" >> "$TARGET_LIST_BSA"
                    fi
                else
                    logowl "Failed to mount: $app_path, error code: $?" "ERROR"
                fi
                BLOCKED_APPS_COUNT=$((BLOCKED_APPS_COUNT + 1))
                break
                if [[ "${package:0:1}" == "/" ]]; then
                    logowl "Custom dir not found: $app_path" "WARN"
                    break
                else
                    logowl "Dir not found: $app_path" "WARN"
                fi
            fi
        done
    done < "$TARGET_LIST"

    if [ "$TARGET_LIST_UPD" == true ]; then
        logowl "Tidy up the target list"
        cp -p "$TARGET_LIST_BSA" "$TARGET_LIST"
    fi

}

module_status_update(){

    APP_NOT_FOUND=$((TOTAL_APPS_COUNT - BLOCKED_APPS_COUNT))
    logowl "$TOTAL_APPS_COUNT APP(s) in total"
    logowl "$BLOCKED_APPS_COUNT APP(s) slain"
    logowl "$APP_NOT_FOUND APP(s) not found"

    if [ -f "$MODULE_PROP" ]; then
        if [ $BLOCKED_APPS_COUNT -gt 0 ]; then
            DESCRIPTION="[üòãEnabled. $BLOCKED_APPS_COUNT APP(s) slain, $APP_NOT_FOUND APP(s) missing, $TOTAL_APPS_COUNT APP(s) targeted in total, Root: $ROOT_SOL] Âãù„Å£„Åü„ÄÅÂãù„Å£„Åü„ÄÅ„Åæ„ÅüÂãù„Å£„Åü„ÅÅ„Éº„Å£„Å®ÔºÅÔºÅüéâ"
            if [ $APP_NOT_FOUND -eq 0 ]; then
            DESCRIPTION="[üòãEnabled. $BLOCKED_APPS_COUNT APP(s) slain. All targets neutralized! Root: $ROOT_SOL] Âãù„Å£„Åü„ÄÅÂãù„Å£„Åü„ÄÅ„Åæ„ÅüÂãù„Å£„Åü„ÅÅ„Éº„Å£„Å®ÔºÅÔºÅüéâ"
            fi
        else
            if [ $TOTAL_APPS_COUNT -gt 0]; then
                DESCRIPTION="[üòãEnabled. No APP slain yet, $TOTAL_APPS_COUNT APP(s) targeted in total, Root: $ROOT_SOL] Âãù„Å£„Åü„ÄÅÂãù„Å£„Åü„ÄÅ„Åæ„ÅüÂãù„Å£„Åü„ÅÅ„Éº„Å£„Å®ÔºÅÔºÅüéâ"
            else
                logowl "! Current blocked apps count: $TOTAL_APPS_COUNT <= 0"
                DESCRIPTION="[‚ùåDisabled. Abnormal status! Root: $ROOT_SOL] A Magisk module to remove bloatware in systemlessly way‚ú®"
            fi
        fi
        update_module_description "$DESCRIPTION" "$MODULE_PROP"
    else
        logowl "module.prop not found, skip updating" "WARN"
    fi

}

. "$MODDIR/aautilities.sh"
install_env_check
init_logowl "$LOG_DIR"

logowl "Magisk Module Info"
print_line >> $LOG_FILE
logowl "$MOD_NAME"
logowl "By $MOD_AUTHOR"
logowl "Version: $MOD_VER"
logowl "Root solution: $ROOT_SOL"
logowl "Current time stamp: $(date +"%Y-%m-%d %H:%M:%S")"
logowl "Starting service.sh..."
print_line >> $LOG_FILE
logowl "env Info"
print_line >> $LOG_FILE
env | sed 's/^/- /' >> $LOG_FILE
print_line >> $LOG_FILE
logowl "Start service"
print_line >> $LOG_FILE

brick_rescue
preparation
bloatware_slayer
module_status_update

{    

    logowl "Current booting timeout: $TIMEOUT"
    while [ "$(getprop sys.boot_completed)" != "1" ]; do
        if [ $TIMEOUT -le "0" ]; then
            print_line >> $LOG_FILE
            logowl "Detect failed to boot after reaching the set limit, your device may be bricked by !" "FATAL"
            logowl "Please make sure no improper APP(s) being blocked!" "FATAL"
            logowl "Mark status as bricked"
            touch "$BRICKED_STATUS"
            print_line >> $LOG_FILE
            logowl "Rebooting..."
            sync
            reboot
            sleep 5
            logowl "Reboot command did not take effect, exiting..."
            exit 1
        fi
        TIMEOUT=$((TIMEOUT-1))
        sleep 1
    done

    logowl "Boot complete! Final countdown: $TIMEOUT s"
    logowl "service.sh case closed!"
    print_line >> $LOG_FILE

    MOD_DESC_OLD=$(sed -n 's/^description=//p' "$MODULE_PROP")
    MOD_LAST_STATUS=""
    MOD_CURRENT_STATUS=""
    MOD_REAL_TIME_DESC=""
    while true; do
        if [ -f "$MODDIR/remove" ]; then
            MOD_CURRENT_STATUS="remove"
        elif [ -f "$MODDIR/disable" ]; then
            MOD_CURRENT_STATUS="disable"
        else
            MOD_CURRENT_STATUS="enabled"
        fi
        if [ "$MOD_CURRENT_STATUS" != "$MOD_LAST_STATUS" ]; then
            logowl "Detect status changed:$MOD_LAST_STATUS -> $MOD_CURRENT_STATUS"
            if [ "$MOD_CURRENT_STATUS" == "remove" ]; then
                logowl "Detect module is set as remove"
                MOD_REAL_TIME_DESC="[üóëÔ∏èRemove (Reboot to take effect), Root: $ROOT_SOL] A Magisk module to remove bloatware in systemlessly way‚ú®"
            elif [ "$MOD_CURRENT_STATUS" == "disable" ]; then
                logowl "Detect module is set as disable"
                MOD_REAL_TIME_DESC="[‚ùåDisable (Reboot to take effect), Root: $ROOT_SOL] A Magisk module to remove bloatware in systemlessly way‚ú®"
            else
                logowl "Detect module is set as enabled"
                MOD_REAL_TIME_DESC="$MOD_DESC_OLD"
            fi
            update_module_description "$MOD_REAL_TIME_DESC" "$MODULE_PROP"
            MOD_LAST_STATUS="$MOD_CURRENT_STATUS"
        fi
        sleep 3
    done
} &
